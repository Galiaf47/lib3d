<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: locator.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: locator.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** @module locator 
 * @description Helper for finding free place for new objects
 */

import THREE from 'three';
import _ from 'lodash';

import GridCalculator from './gridCalculator';
import BaseObject from './models/BaseObject';

import * as cache from './cache';
import * as environment from './environment';

var debugEnabled = false;

/** Center an object on scene and avoid collisions
 *
 * @param {BaseObject} obj - an instance of BaseObject,
 * should have calculated bounding box
 */
export function centerObject(obj) {
	var targetBB = obj.geometry.boundingBox;
	var spaceBB = environment.library.geometry.boundingBox;

	var matrixPrecision = new THREE.Vector3(targetBB.max.x - targetBB.min.x + 0.01, 0, targetBB.max.z - targetBB.min.z + 0.01);
	var occupiedMatrix = getOccupiedMatrix(environment.library.children, matrixPrecision, obj);
	var freePosition = getFreeMatrix(occupiedMatrix, spaceBB, targetBB, matrixPrecision);		

	obj.position.setX(freePosition.x);
	obj.position.setZ(freePosition.z);
}

/** Find free space for section in current library
 * 
 * @param {Object} sectionDto - object with model attribute
 * to find appropriate geometry
 * 
 * @returns {Promise|THREE.Vector3} free position
 */
export function placeSection(sectionDto) {
	return cache.getSection(sectionDto.model).then(function (sectionCache) {
		var sectionBB = sectionCache.geometry.boundingBox;
		var libraryBB = environment.library.geometry.boundingBox;
		var freePlace = getFreePlace(environment.library.children, libraryBB, sectionBB);

		if (freePlace) {
			return Promise.resolve(freePlace);
		} else {
			return Promise.reject('there is no free space');
		}
	});
}

/** Find free space for book in provided shelf
 *
 * @param {Object} bookDto - object with model attribute
 * to find appropriate geometry
 * @param {ShelfObject} shelf - an instance of ShelfObject
 *
 * @returns {Promise|THREE.Vector3} free position
 */
export function placeBook(bookDto, shelf) {
	return cache.getBook(bookDto.model).then(function (bookCache) {
		var shelfBB = shelf.geometry.boundingBox;
		var bookBB = bookCache.geometry.boundingBox;
		var freePlace = getFreePlace(shelf.children, shelfBB, bookBB);

		return freePlace ?
			Promise.resolve(freePlace) :
			Promise.reject('there is no free space');
	});
}

function getFreePlace(objects, spaceBB, targetBB) {
	var matrixPrecision = new THREE.Vector3(targetBB.max.x - targetBB.min.x + 0.01, 0, targetBB.max.z - targetBB.min.z + 0.01);
	var occupiedMatrix = getOccupiedMatrix(objects, matrixPrecision);
	var freePosition = getFreeMatrixCells(occupiedMatrix, spaceBB, targetBB, matrixPrecision);
	
	if (debugEnabled) {
		debugShowFree(freePosition, matrixPrecision, environment.library);
	}

	return freePosition;
}

function getFreeMatrix(occupiedMatrix, spaceBB, targetBB, matrixPrecision) {
	var DISTANCE = 1.3;

	var xIndex;
	var zIndex;
	var position = {};
	var minPosition = {};
	var edges = GridCalculator.getEdges(spaceBB, matrixPrecision);

	for (zIndex = edges.minZCell; zIndex &lt;= edges.maxZCell; zIndex++) {
		for (xIndex = edges.minXCell; xIndex &lt;= edges.maxXCell; xIndex++) {
			if (!occupiedMatrix[zIndex] || !occupiedMatrix[zIndex][xIndex]) {
				position.pos = getPositionFromCells([xIndex], zIndex, matrixPrecision, spaceBB, targetBB);
				position.length = position.pos.length();

				if(!minPosition.pos || position.length &lt; minPosition.length) {
					minPosition.pos = position.pos;
					minPosition.length = position.length;
				}

				if(minPosition.pos &amp;&amp; minPosition.length &lt; DISTANCE) {
					return minPosition.pos;
				}
			}
		}
	}

	return minPosition.pos;
}

function getFreeMatrixCells(occupiedMatrix, spaceBB, targetBB, matrixPrecision) {
	var targetCellsSize = 1;
	var freeCellsCount = 0;
	var freeCellsStart;
	var xIndex;
	var zIndex;
	var cells;
	var edges = GridCalculator.getEdges(spaceBB, matrixPrecision);

	for (zIndex = edges.minZCell; zIndex &lt;= edges.maxZCell; zIndex++) {
		for (xIndex = edges.minXCell; xIndex &lt;= edges.maxXCell; xIndex++) {
			if (!occupiedMatrix[zIndex] || !occupiedMatrix[zIndex][xIndex]) {
				freeCellsStart = freeCellsStart || xIndex;
				freeCellsCount++;

				if (freeCellsCount === targetCellsSize) {
					cells = _.range(freeCellsStart, freeCellsStart + freeCellsCount);
					return getPositionFromCells(cells, zIndex, matrixPrecision, spaceBB, targetBB);
				}
			} else {
				freeCellsCount = 0;
			}
		}
	}

	return null;
}

function getPositionFromCells(cells, zIndex, matrixPrecision, spaceBB, targetBB) {
	var center = GridCalculator.cellToPos(new THREE.Vector3(cells[0], 0, zIndex), matrixPrecision);

	var offset = new THREE.Vector3();
	offset.addVectors(targetBB.min, targetBB.max);
	offset.multiplyScalar(-0.5);

	return center.add(offset).setY(getBottomY(spaceBB, targetBB));
}

function getBottomY(spaceBB, targetBB) {
	return spaceBB.min.y - targetBB.min.y + environment.CLEARANCE;
}

function getOccupiedMatrix(objects, matrixPrecision, obj) {
	var result = {};
	var objectBB;
	var minKeyX;
	var maxKeyX;
	var minKeyZ;
	var maxKeyZ;
	var z, x;

	objects.forEach(function (child) {
		if(child instanceof BaseObject &amp;&amp; child !== obj) {
			objectBB = child.boundingBox;

			minKeyX = Math.round((objectBB.center.x - objectBB.radius.x) / matrixPrecision.x);
			maxKeyX = Math.round((objectBB.center.x + objectBB.radius.x) / matrixPrecision.x);
			minKeyZ = Math.round((objectBB.center.z - objectBB.radius.z) / matrixPrecision.z);
			maxKeyZ = Math.round((objectBB.center.z + objectBB.radius.z) / matrixPrecision.z);

			for(z = minKeyZ; z &lt;= maxKeyZ; z++) {
				result[z] = result[z] || {};
				var debugCells = [];

				for(x = minKeyX; x &lt;= maxKeyX; x++) {
					result[z][x] = true;
					debugCells.push(x);
				}

				if(debugEnabled) {
					debugShowBB(child);
					debugAddOccupied(debugCells, matrixPrecision, child, z);
				}
			}
		}
	});

	return result;
}

export function debug() {
	cache.getSection('bookshelf_0001').then(function (sectionCache) {
		debugEnabled = true;
		var sectionBB = sectionCache.geometry.boundingBox;
		var libraryBB = environment.library.geometry.boundingBox;
		getFreePlace(environment.library.children, libraryBB, sectionBB);
		debugEnabled = false;
	});
}

function debugShowBB(obj) {
	var objectBB = obj.boundingBox;
	var objBox = new THREE.Mesh(
		new THREE.BoxGeometry(
			objectBB.radius.x * 2, 
			objectBB.radius.y * 2 + 0.1, 
			objectBB.radius.z * 2
		), 
		new THREE.MeshLambertMaterial({
			color: 0xbbbbff,
			opacity: 0.2,
			transparent: true
		})
	);
	
	objBox.position.x = objectBB.center.x;
	objBox.position.y = objectBB.center.y;
	objBox.position.z = objectBB.center.z;

	obj.parent.add(objBox);
}

function debugAddOccupied(cells, matrixPrecision, obj, zKey) {
	cells.forEach(function (cell) {
		var pos = getPositionFromCells([cell], zKey, matrixPrecision, obj.parent.geometry.boundingBox, obj.geometry.boundingBox);
		var cellBox = new THREE.Mesh(new THREE.BoxGeometry(matrixPrecision.x - 0.01, 0.01, matrixPrecision.z - 0.01), new THREE.MeshLambertMaterial({color: 0xff0000}));
		
		cellBox.position.set(pos.x, pos.y, pos.z);
		obj.parent.add(cellBox);
	});
}

function debugShowFree(position, matrixPrecision, obj) {
	if (position) {
		var cellBox = new THREE.Mesh(new THREE.BoxGeometry(matrixPrecision.x, 0.5, matrixPrecision.z), new THREE.MeshLambertMaterial({color: 0x00ff00}));
		cellBox.position.set(position.x, position.y, position.z);
		obj.parent.add(cellBox);
	}
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-camera.html">camera</a></li><li><a href="module-environment.html">environment</a></li><li><a href="module-lib3d.html">lib3d</a></li><li><a href="module-locator.html">locator</a></li><li><a href="module-mouse.html">mouse</a></li><li><a href="module-navigation.html">navigation</a></li><li><a href="module-preview.html">preview</a></li><li><a href="module-selector.html">selector</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Thu Jan 28 2016 09:51:34 GMT+0300 (Belarus Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
